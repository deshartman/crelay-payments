import twilio from 'twilio';
import { EventEmitter } from 'events';
import { logOut, logError } from '../utils/logger.js';
import VoiceResponse from 'twilio/lib/twiml/VoiceResponse.js';
import { TwilioSyncService } from './TwilioSyncService.js';
import { ConversationRelayConfig } from '../interfaces/ConversationRelay.js';

/**
 * Interface for status callback object
 */
interface StatusCallback {
    CallSid: string;
    [key: string]: any;
}

/**
 * Service class for handling Twilio-related operations including making calls, sending SMS and generating TwiML for the Conversation Relay service.
 * 
 * @class
 * @property {string} accountSid - Twilio account SID from environment variables
 * @property {string} authToken - Twilio authentication token from environment variables
 * @property {string} fromNumber - Twilio phone number to use as the sender
 * @property {twilio.Twilio} twilioClient - Initialized Twilio client instance
 */
class TwilioService extends EventEmitter {
    private accountSid: string;
    private authToken: string;
    private fromNumber: string;
    private twilioClient: twilio.Twilio;
    private syncService: TwilioSyncService;

    constructor() {
        super();
        this.accountSid = process.env.ACCOUNT_SID || '';
        this.authToken = process.env.AUTH_TOKEN || '';
        this.fromNumber = process.env.FROM_NUMBER || '';
        this.twilioClient = twilio(process.env.ACCOUNT_SID || '', process.env.AUTH_TOKEN || '');
        this.syncService = new TwilioSyncService(this.twilioClient);
        // this.twilioClient = twilio(process.env.API_KEY, process.env.API_SECRET, { process.env.ACCOUNT_SID });    // Some issue here with the API key and secret
    }

    /**
     * Initialize the Sync Service with all required services and maps
     */
    async initialize(): Promise<void> {
        await this.syncService.initialize();
    }

    /**
     * Helper function to filter out unset values from configuration
     */
    private filterUnsetValues(config: any): any {
        const filtered: any = {};

        Object.entries(config).forEach(([key, value]) => {
            if (value !== null && value !== undefined && value !== '' &&
                !(Array.isArray(value) && value.length === 0)) {
                filtered[key] = value;
            }
        });

        return filtered;
    }

    /**
     * Makes an outbound call and connects it to the Conversation Relay service.
     * The call is automatically recorded and uses TwiML generated by connectConversationRelay.
     * 
     * @param {string} toNumber - The destination phone number in E.164 format
     * @param {string} callReference - Unique reference ID for the customer
     * @param {string} serverBaseUrl - Base URL for the Conversation Relay WebSocket server (without wss:// prefix)
     * @returns {Promise<any>} The Twilio call object if successful
     * @throws {Error} If the call cannot be initiated or other Twilio API errors occur
     */
    async makeOutboundCall(serverBaseUrl: string, toNumber: string, callReference: string = ""): Promise<any> {
        try {
            const conversationRelay = await this.connectConversationRelay(serverBaseUrl, callReference);

            if (!conversationRelay) {
                throw new Error('Failed to generate TwiML for conversation relay');
            }

            const call = await this.twilioClient.calls.create({
                to: toNumber,
                from: this.fromNumber,
                twiml: conversationRelay.toString(),
                // record: true,
            });

            logOut('TwilioService', `Made a call from: ${this.fromNumber} to: ${toNumber}`);
            return call;

        } catch (error) {
            logError('TwilioService', `Make Outbound call error: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    /**
     * Sends an SMS message using the configured Twilio number.
     * 
     * @param {string} to - The destination phone number in E.164 format
     * @param {string} message - The message content to send
     * @returns {Promise<string|null>} The Twilio message SID if successful, null if sending fails
     */
    async sendSMS(to: string, message: string): Promise<string | null> {
        try {
            logOut('TwilioService', `Sending SMS to: ${to} with message: ${message}`);

            const response = await this.twilioClient.messages.create({
                body: message,
                from: this.fromNumber,
                to: to
            });
            return response.sid;
        } catch (error) {
            logError('TwilioService', `Error sending SMS: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Generates TwiML to connect a call to the Conversation Relay service.
     * Uses dynamic configuration from Sync Maps instead of hardcoded values.
     * Can be used for both inbound and outbound calls.
     * 
     * @param {string} serverBaseUrl - Base URL for the Conversation Relay WebSocket server (without wss:// prefix)
     * @param {string} callReference - Unique reference ID for the customer
     * @returns {Promise<twilio.twiml.VoiceResponse|null>} The TwiML response object if successful, null if generation fails
     */
    async connectConversationRelay(serverBaseUrl: string, callReference: string = ""): Promise<twilio.twiml.VoiceResponse | null> {
        try {
            logOut('TwilioService', `Generating TwiML for call with callReference: ${callReference}`);

            // Get configuration from Sync using UsedConfig
            const usedConfig = await this.getUsedConfig();
            const config = await this.getConversationRelayConfig(usedConfig.configuration);
            const languages = await this.getLanguages();

            if (!config) {
                logError('TwilioService', 'No ConversationRelay configuration found in Sync');
                return null;
            }

            // Generate the TwiML with dynamic configuration
            const response: VoiceResponse = new twilio.twiml.VoiceResponse();
            const connect: VoiceResponse.Connect = response.connect();
            const filteredConfig = this.filterUnsetValues(config);
            const conversationRelay: VoiceResponse.ConversationRelay = connect.conversationRelay({
                url: `wss://${serverBaseUrl}/conversation-relay`,
                ...filteredConfig
            } as any);

            // Add language configurations if available
            if (languages) {
                Object.keys(languages).forEach(langCode => {
                    const langConfig = languages[langCode];
                    if (langConfig && langConfig.ttsProvider && langConfig.voice) {
                        conversationRelay.language({
                            code: langCode,
                            ttsProvider: langConfig.ttsProvider,
                            voice: langConfig.voice,
                        });
                    }
                });
            }

            conversationRelay.parameter({
                name: 'callReference',
                value: callReference
            });

            // logOut('TwilioService', `Generated TwiML using Helper for call: ${response.toString()}`);

            return response;

        } catch (error) {
            logError('TwilioService', `Error generating call TwiML: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    // ========== Configuration Management API ==========

    /**
     * Get ConversationRelay configuration
     * @param key Optional specific configuration key
     * @returns Configuration value(s)
     */
    async getConversationRelayConfig(key?: string): Promise<any> {
        return await this.syncService.getMapItem('ConversationRelay', 'Configuration', key);
    }

    /**
     * Set ConversationRelay configuration
     * @param key Configuration key
     * @param value Configuration value
     */
    async setConversationRelayConfig(key: string, value: any): Promise<void> {
        await this.syncService.setMapItem('ConversationRelay', 'Configuration', key, value);
    }

    /**
     * Delete ConversationRelay configuration
     * @param key Configuration key to delete
     */
    async deleteConversationRelayConfig(key: string): Promise<void> {
        await this.syncService.deleteMapItem('ConversationRelay', 'Configuration', key);
    }

    // ========== Language Management API ==========

    /**
     * Get language configurations
     * @param key Optional specific language key
     * @returns Language configuration(s)
     */
    async getLanguages(key?: string): Promise<any> {
        return await this.syncService.getMapItem('ConversationRelay', 'Languages', key);
    }

    /**
     * Set language configuration
     * @param key Language key
     * @param value Language configuration
     */
    async setLanguage(key: string, value: any): Promise<void> {
        await this.syncService.setMapItem('ConversationRelay', 'Languages', key, value);
    }

    /**
     * Delete language configuration
     * @param key Language key to delete
     */
    async deleteLanguage(key: string): Promise<void> {
        await this.syncService.deleteMapItem('ConversationRelay', 'Languages', key);
    }

    // ========== UsedConfig Management API ==========

    /**
     * Get used configuration
     * @param key Optional specific used config key
     * @returns Used configuration value(s)
     */
    async getUsedConfig(key?: string): Promise<any> {
        const usedConfig = await this.syncService.getDocument('ConversationRelay', 'UsedConfig');
        if (key) {
            return usedConfig ? usedConfig[key] : null;
        }
        return usedConfig;
    }

    /**
     * Set used configuration
     * @param key Used config key
     * @param value Used configuration value
     */
    async setUsedConfig(key: string, value: any): Promise<void> {
        const usedConfig = await this.syncService.getDocument('ConversationRelay', 'UsedConfig') || {};
        usedConfig[key] = value;
        await this.syncService.setDocument('ConversationRelay', 'UsedConfig', usedConfig);
    }

    /**
     * Set the entire used configuration
     * @param config Complete used configuration object
     */
    async setUsedConfigComplete(config: any): Promise<void> {
        await this.syncService.setDocument('ConversationRelay', 'UsedConfig', config);
    }

    // ========== Context Management API ==========

    /**
     * Get context content
     * @param key Optional specific context key
     * @returns Context content(s)
     */
    async getContext(key?: string): Promise<any> {
        return await this.syncService.getMapItem('ConversationRelay', 'Context', key);
    }

    /**
     * Set context content
     * @param key Context key
     * @param value Context content
     */
    async setContext(key: string, value: string): Promise<void> {
        await this.syncService.setMapItem('ConversationRelay', 'Context', key, value);
    }

    /**
     * Delete context content
     * @param key Context key to delete
     */
    async deleteContext(key: string): Promise<void> {
        await this.syncService.deleteMapItem('ConversationRelay', 'Context', key);
    }

    // ========== Tool Manifest Management API ==========

    /**
     * Get tool manifest content
     * @param key Optional specific manifest key
     * @returns Tool manifest content(s)
     */
    async getToolManifest(key?: string): Promise<any> {
        return await this.syncService.getMapItem('ConversationRelay', 'ToolManifest', key);
    }

    /**
     * Set tool manifest content
     * @param key Manifest key
     * @param value Manifest content
     */
    async setToolManifest(key: string, value: any): Promise<void> {
        await this.syncService.setMapItem('ConversationRelay', 'ToolManifest', key, value);
    }

    /**
     * Delete tool manifest content
     * @param key Manifest key to delete
     */
    async deleteToolManifest(key: string): Promise<void> {
        await this.syncService.deleteMapItem('ConversationRelay', 'ToolManifest', key);
    }

    /**
     * Evaluate the status callback received. This will be used in the LLM to determine the next steps.
     * If there is nothing to be done, just null the response.
     * 
     * @param statusCallback - The status callback object from Twilio
     * @returns The evaluated status callback object or null
     */
    async evaluateStatusCallback(statusCallback: StatusCallback): Promise<StatusCallback | null> {
        try {
            logOut('TwilioService', `Evaluating status callback: ${JSON.stringify(statusCallback)}`);
            // Do something and then emit the event type
            const callSid = statusCallback.CallSid;
            logOut('TwilioService', `Returning evaluated status callback for callSid: ${callSid}`);
            return statusCallback;
        } catch (error) {
            logError('TwilioService', `Error evaluating status callback: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }
}

export { TwilioService };
